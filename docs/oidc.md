# Configuring Headscale to use OIDC authentication

In order to authenticate users through a centralized solution one must enable the OIDC integration.

Known limitations:

- No dynamic ACL support
- OIDC groups cannot be used in ACLs

## Basic configuration

In your `config.yaml`, customize this to your liking:

```yaml
oidc:
  # Block further startup until the OIDC provider is healthy and available
  only_start_if_oidc_is_available: true
  # Specified by your OIDC provider
  issuer: "https://your-oidc.issuer.com/path"
  # Specified/generated by your OIDC provider
  client_id: "your-oidc-client-id"
  client_secret: "your-oidc-client-secret"
  # alternatively, set `client_secret_path` to read the secret from the file.
  # It resolves environment variables, making integration to systemd's
  # `LoadCredential` straightforward:
  #client_secret_path: "${CREDENTIALS_DIRECTORY}/oidc_client_secret"
  # as third option, it's also possible to load the oidc secret from environment variables
  # set HEADSCALE_OIDC_CLIENT_SECRET to the required value

  # When true, attempt to automatically user accounts from Headscale 0.23.0 and earlier.
  # ENABLING THIS OPTION CAN BE A SECURITY RISK.
  # See "Migrating from Headscale 0.23.0 and earlier" in the manual below.
  migrate_legacy_users: false

  # When true, allows sign-in with OIDC with an unverified (according to the
  # provider) email address claim. Some providers use this to signal an
  # unverified self-service email address change, so ENABLING THIS OPTION CAN BE
  # A SECURITY ISSUE.
  allow_unverified_email: false

  # Customize the scopes used in the OIDC flow, defaults to "openid", "profile" and "email" and add custom query
  # parameters to the Authorize Endpoint request. Scopes default to "openid", "profile" and "email".
  scope: ["openid", "profile", "email", "custom"]
  # Optional: Passed on to the browser login request â€“ used to tweak behaviour for the OIDC provider
  extra_params:
    domain_hint: example.com

  # Optional: List allowed principal domains and/or users. If an authenticated user's domain is not in this list,
  # the authentication request will be rejected.
  allowed_domains:
    - example.com
  # Optional. Note that groups from Keycloak have a leading '/'.
  allowed_groups:
    - /headscale
  # Optional.
  allowed_users:
    - alice@example.com
```

## Migrating from Headscale 0.23.0 and earlier

**NOT YET IMPLEMENTED:** See https://github.com/juanfont/headscale/pull/2170 for
discussion.

Headscale 0.23.0 and earlier have several flaws in their OIDC implementation,
which could allow an attacker to compromise accounts in a Headscale instance.

### Background and issues

An OIDC identity provider gives a number of attributes (claims) to an
application (like Headscale) about the person (or other identity) trying to log
in.

Headscale 0.23.0 and earlier mapped OIDC users to local users based the contents
of the `email` claim (attribute) with the domain part of the address stripped by
default (the `oidc.strip_email_domain` option).

This made for short usernames, but was contrary to
[OIDC recommendations][oidc-sub], which say that only the `sub` (unique subject
identifier) and `iss` (issuer) together can be relied on as a stable unique user
identifier.

This has a number of issues, which **could lead to account compromise**:

- An OIDC provider may allow unverified, user-initiated email address changes,
  and may not enforce a uniqueness constraint on email addresses.

  This could allow a malicious user to take over others' Headscale accounts by
  setting their own account's `email` to that of another user.

- By default, Headscale would treat two users with the same "user" part of their
  email address but different domains (eg: `user@example.com` and
  `user@example.net`) *as the same user*.

  This could be mitigated if an administrator set `oidc.allowed_domains` to
  exactly **one** domain, or by setting `oidc.strip_email_domain: false`.

- If an OIDC account changed email address, Headscale would create a new
  account, even if it had the same `sub` (unique identifier).

- Even if an identity provider knew an address to be unverified and told
  Headscale about it (with `email_verified = false`), Headscale didn't read this
  field.

Headscale 0.xx.x fixes this, and significantly changes how it uses OIDC:

- Headscale now correctly uses the `sub` attribute to uniquely identify users.

  This is a stable identifier which should track user renames and email address
  changes in the OIDC provider.

- Headscale will *always* use the `preferred_username` attribute to set the
  account's username, and the `oidc.strip_email_domain` option has been removed.

  This might be a short name (eg: `user`), an email address, an [SPN][], a
  [UPN][] or a phone number. This is configurable in some identity providers â€“ 
  see their docs for help.

- Setting `oidc.map_legacy_users: true` setting (defaults to `false`) allows you
  to attempt to automatically map users based on the `Email` in their profile.

  **FIXME, BROKEN:** #2020 added this field, so we can't actually do this ðŸ˜­

### Migration steps

TODO

[oidc-sub]: https://openid.net/specs/openid-connect-basic-1_0.html#ClaimStability
[SPN]: https://learn.microsoft.com/en-us/windows/win32/ad/service-principal-names
[UPN]: https://learn.microsoft.com/en-us/windows/win32/ad/naming-properties#userprincipalname


## Azure AD example

In order to integrate Headscale with Azure Active Directory, we'll need to provision an App Registration with the correct scopes and redirect URI. Here with Terraform:

```hcl
resource "azuread_application" "headscale" {
  display_name = "Headscale"

  sign_in_audience = "AzureADMyOrg"
  fallback_public_client_enabled = false

  required_resource_access {
    // Microsoft Graph
    resource_app_id = "00000003-0000-0000-c000-000000000000"

    resource_access {
      // scope: profile
      id   = "14dad69e-099b-42c9-810b-d002981feec1"
      type = "Scope"
    }
    resource_access {
      // scope: openid
      id   = "37f7f235-527c-4136-accd-4a02d197296e"
      type = "Scope"
    }
    resource_access {
      // scope: email
      id   = "64a6cdd6-aab1-4aaf-94b8-3cc8405e90d0"
      type = "Scope"
    }
  }
  web {
    # Points at your running Headscale instance
    redirect_uris = ["https://headscale.example.com/oidc/callback"]

    implicit_grant {
      access_token_issuance_enabled = false
      id_token_issuance_enabled = true
    }
  }

  group_membership_claims = ["SecurityGroup"]
  optional_claims {
    # Expose group memberships
    id_token {
      name = "groups"
    }
  }
}

resource "azuread_application_password" "headscale-application-secret" {
  display_name          = "Headscale Server"
  application_object_id = azuread_application.headscale.object_id
}

resource "azuread_service_principal" "headscale" {
  application_id = azuread_application.headscale.application_id
}

resource "azuread_service_principal_password" "headscale" {
  service_principal_id = azuread_service_principal.headscale.id
  end_date_relative    = "44640h"
}

output "headscale_client_id" {
  value = azuread_application.headscale.application_id
}

output "headscale_client_secret" {
  value = azuread_application_password.headscale-application-secret.value
}
```

And in your Headscale `config.yaml`:

```yaml
oidc:
  issuer: "https://login.microsoftonline.com/<tenant-UUID>/v2.0"
  client_id: "<client-id-from-terraform>"
  client_secret: "<client-secret-from-terraform>"

  # Optional: add "groups"
  scope: ["openid", "profile", "email"]
  extra_params:
    # Use your own domain, associated with Azure AD
    domain_hint: example.com
    # Optional: Force the Azure AD account picker
    prompt: select_account
```

## Google OAuth Example

In order to integrate Headscale with Google, you'll need to have a [Google Cloud Console](https://console.cloud.google.com) account.

Google OAuth has a [verification process](https://support.google.com/cloud/answer/9110914?hl=en) if you need to have users authenticate who are outside of your domain. If you only need to authenticate users from your domain name (ie `@example.com`), you don't need to go through the verification process.

However if you don't have a domain, or need to add users outside of your domain, you can manually add emails via Google Console.

### Steps

1. Go to [Google Console](https://console.cloud.google.com) and login or create an account if you don't have one.
2. Create a project (if you don't already have one).
3. On the left hand menu, go to `APIs and services` -> `Credentials`
4. Click `Create Credentials` -> `OAuth client ID`
5. Under `Application Type`, choose `Web Application`
6. For `Name`, enter whatever you like
7. Under `Authorised redirect URIs`, use `https://example.com/oidc/callback`, replacing example.com with your Headscale URL.
8. Click `Save` at the bottom of the form
9. Take note of the `Client ID` and `Client secret`, you can also download it for reference if you need it.
10. Edit your headscale config, under `oidc`, filling in your `client_id` and `client_secret`:

```yaml
oidc:
  issuer: "https://accounts.google.com"
  client_id: ""
  client_secret: ""
  scope: ["openid", "profile", "email"]
```

You can also use `allowed_domains` and `allowed_users` to restrict the users who can authenticate.
